#pragma once

#include <map>
#include <vector>
#include <algorithm>
#include "PackageManager.h"
#include "Utilities/Flags.h"
#include "Logging/Logging.h"

#include "PackageSpec.h"

#include "CRC32.h"

BEGINNAMESPACE

struct AnimationSpec;
struct AudioSpec;
struct LightSpec;
struct MaterialSpec;
struct MeshSpec;
struct GeometrySpec;
struct SceneSpec;
struct TextureSpec;

template<typename T> struct ResType {};
template<> struct ResType<AnimationSpec> { static const uint32 type = uint32(ResourceType::Animation); };
template<> struct ResType<AudioSpec> { static const uint32 type = uint32(ResourceType::Audio); };
template<> struct ResType<GeometrySpec> { static const uint32 type = uint32(ResourceType::Geometry); };
template<> struct ResType<LightSpec> { static const uint32 type = uint32(ResourceType::Light); };
template<> struct ResType<MaterialSpec> { static const uint32 type = uint32(ResourceType::Material); };
template<> struct ResType<MeshSpec> { static const uint32 type = uint32(ResourceType::Mesh); };
template<> struct ResType<SceneSpec> { static const uint32 type = uint32(ResourceType::Scene); };
template<> struct ResType<TextureSpec> { static const uint32 type = uint32(ResourceType::Texture); };

//
// A package is a combination of all necessary resources for a scene
// It consists of Meshes / Textures / Materials / Animation / Lights / Audio
// A package is generated by a loadable sceen file within the ${sceen_root} and the sub folders of the corresponding resource folder with the same same
// eg.:
//	scenes/SamplePackage/*.(DAE/FBX/...)
//	textures/SamplePackage/*.dds
//	mesh/SamplePackage/*.mesh
//	audio/SamplePackage/*.wav
//	animation/SamplePackage/*.anim
//	lights/SamplePackage/*.light
//	materials/SamplePackage/*.material
// will be combined into one SamplePackage.pkg package in the ${package_root} folder
//
// The first part of the memory will be a library for all contained resources
class Package {
	
	struct EntryHeader {
		uint32 type; 
		uint32 size;
		uint32 hash;
		uint32 timestamp;
	};

	template<typename Resource>
	struct Storage {
		path file;
		const Resource* resource;
		EntryHeader header;
	};
public:
	Package();
	Package(const String& pkgName, const PackageManager& mgr);

	bool load(const path& filename, const PackageManager& mgr);
	bool store(const PackageManager& mgr);
	void update(const PackageManager& mgr);
		
	void addAnimationFromScene(AnimationSpec* animation, const path& sceneFile, uint32 animationSize, uint32 hash, uint32 timeStamp);
	void addAudioFromScene(AudioSpec* audio, const path& sceneFile, uint32 audioSize, uint32 hash, uint32 timeStamp);
	void addGeometryFromScene(GeometrySpec* geometry, const path& sceneFile, uint32 audioSize, uint32 hash, uint32 timeStamp);
	void addLightFromScene(LightSpec* light, const path& sceneFile, uint32 lightSize, uint32 hash, uint32 timeStamp);
	void addMaterialFromScene(MaterialSpec* material, const path& sceneFile, uint32 materialSize, uint32 hash, uint32 timeStamp);
	void addMeshFromScene(MeshSpec* mesh, const path& sceneFile, uint32 meshSize, uint32 hash, uint32 timeStamp);
	void addTextureFromScene(TextureSpec* texture, const path& sceneFile, uint32 textureSize, uint32 hash, uint32 timeStamp);
	
	uint32 getRecentTimeStamp();

	inline const String& getPackageName() const {
		return m_packageName;
	}

	bool alreadyTracked(const path& file);
	void setFileTracked(const path& file);
	void attachTracked(uint32 hash);
private:
	void readHeader(Byte*, EntryHeader&, size_type& off);
	void storeHeader(FILE*, EntryHeader&);
		
	uint32 update_scene();

	template<typename Resource, typename F_load, typename F_size>
	uint32 updater(const path& folder, std::vector<Storage<Resource>>& resources, F_load res_loader, F_size res_size) {
		uint32 max_currentTimeStamp = m_RecentTimestamp;

		if (!is_directory(folder)) return max_currentTimeStamp; //The Package has no folder in the resource-folder

		for (auto& file_entry : directory_iterator(folder)) {
			path file = file_entry.path();
			if (!is_regular_file(file)) continue;

			file_time_type ft = last_write_time(file);
			uint32 currentTimeStamp = std::chrono::system_clock::to_time_t(ft);

			if (alreadyTracked(file)) {
				//This file was processed before: check wheter it has to be updated
				if (currentTimeStamp < m_RecentTimestamp) continue; //this resource is up to date
			}

			//This file is either out of date or wasn't tracked before
			std::vector<Resource*> res_es = res_loader(file); //load from file;
			if (res_es.empty()) {
				LOG_ERROR(General, "The resource (%s) load failed.", file.c_str());
				continue;
			}

			Resource* resource = res_es[0]; //load from file
			String name = file.stem().string();
			uint32 hash = crc32((Byte*)name.c_str(), name.length());
			EntryHeader header = { uint32( ResType<Resource>::type ), res_size(resource), hash, currentTimeStamp };
			setFileTracked(file);

            typename std::vector<Storage<Resource>>::iterator fnd = std::find_if(resources.begin(), resources.end(), [&](Storage<Resource>& entry)->bool {
				return entry.header.hash == hash;
			});

			if (fnd == resources.end()) {
				Storage<Resource> res;
				res.file = file;
				res.header = header;
				res.resource = resource;
				resources.push_back(res);
			}
			else {
				fnd->file = file;
				fnd->header = header;
				fnd->resource = resource;
			}
			m_Dirty = true;
			max_currentTimeStamp = std::max(currentTimeStamp, max_currentTimeStamp);
		}
		return max_currentTimeStamp;
	}

private:
	uint32 m_RecentTimestamp;
	uint32 m_ResourceCount;

	String m_packageName; //The package name
	path m_PackagePath; //The package file to manage
	
	bool m_Dirty;

	std::vector<path> m_SceneFiles; //The scene files to monitor
	path m_AnimationFolder; //The folder which belongs to the animation files in this pgk
	path m_AudioFolder; //The folder which belongs to the audio files in this pkg
	path m_LightFolder; //The folder which belongs to the light files in this pkg
	path m_MaterialFolder; //The folder which belongs to the material files in this pkg
	path m_MeshFolder; //The folder which belongs to the mesh files in this pkg
	path m_SceneFolder; //The folder which belongs to the scene files in this pkg
	path m_TextureFolder; //The folder which belongs to the texture files in this pkg

	/*
	typedef std::map<String, Animation*> AnimationMap;
	typedef std::map<String, Audio*> AudioMap;
	typedef std::map<String, Light*> LightMap;
	typedef std::map<String, Material*> MaterialMap;
	typedef std::map<String, Mesh*> MeshMap;
	typedef std::map<String, Texture*> TextureMap;
	*/
	typedef std::vector<Storage<AnimationSpec>> AnimationMap;
	typedef std::vector<Storage<AudioSpec>> AudioMap;
	typedef std::vector<Storage<GeometrySpec>> GeometryMap;
	typedef std::vector<Storage<LightSpec>> LightMap;
	typedef std::vector<Storage<MaterialSpec>> MaterialMap;
	typedef std::vector<Storage<MeshSpec>> MeshMap;
	typedef std::vector<Storage<TextureSpec>> TextureMap;

	typedef std::vector<uint32> TrackedFiles;
	TrackedFiles m_TrackedFiles;

	AnimationMap m_Animations;
	AudioMap m_Audio;
	LightMap m_Lights;
	GeometryMap m_Geometries;
	MaterialMap m_Materials;
	MeshMap m_Meshes;
	TextureMap m_Textures;

	Crc32 crc32;
};

ENDNAMESPACE
