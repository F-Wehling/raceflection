#extension GL_ARB_separate_shader_objects : enable
#include "predefines.fxh"
#include "constantBuffer.fxh"
#include "light.fxh"
#include "fragOutput.fxh"

// will lead to a creation of a texture in a specific repository. nvFX will keep track of the Id


//store normals

RenderTexture rt_Normal
{
    MSAA = {0,0};
    Size = ApplicationDefined;
    Format = RG16F;
}

//Store diffuse Color
RenderTexture rt_Color
{
    MSAA = {0,0};
    Size = ApplicationDefined;// a way to dynamically define the size of the resource to create
    Format = RGBA8;
}

RenderTexture rt_Depth
{
	MSAA = {0,0};
	Size = ApplicationDefined;
	//Format = DEPTH32F_STENCIL8;
	Format = DEPTH_COMPONENT32F;
        //Format = DEPTH24STENCIL8;
}

RenderBuffer rb_DepthStencil
{
    MSAA = {0,0};
    Size = ApplicationDefined;
    Format = DEPTH24STENCIL8;
}
// will lead to a FBO creation in a specific repository. nvFX lib will keep track of the Id
FBO deferredRenderFBO
{
    Color = { rt_Normal, rt_Color };
    DepthStencil = rt_Depth;
}

RenderTexture rt_DeferredResult
{
	MSAA = {0,0};
	Size = ApplicationDefined;
	Format = RGBA8;
}

FBO deferredRenderLightFBO 
{
	Color = { rt_DeferredResult };
	DepthStencil = rb_DepthStencil; //rt_Depth;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// sampler states are outside of GLSL.
//
SamplerState nearestSampler
{
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
}

//--------------------------------------------------------------------------------------
/// Deferred Rendering Geometry Pass
//--------------------------------------------------------------------------------------
GLSLShader deferredGeometryVS {
	layout(location = 0) in vec3 position;
	layout(location = 1) in vec3 normal;
	layout(location = 2) in vec4 color;
	layout(location = 3) in vec2 texCoord;
	
	layout(location = 0) out vec3 out_PositionVS;
	layout(location = 1) out vec3 out_Normal;
	layout(location = 2) out vec2 out_TexCoord;
	layout(location = 3) out vec4 out_Color;
		
	out gl_PerVertex{
		vec4 gl_Position;
	};
		
	void main() {
		// Calculate view space position of the vertex
		vec3 positionVS = vec3(m4_ModelView * vec4(position, 1.0));
		out_PositionVS = positionVS;
	
		out_Normal = mat3(m4_ViewIT) * normal;
		out_TexCoord = texCoord;
		out_Color = color;
		gl_Position = m4_ModelViewProjection * vec4(position, 1.0);
	}		
}

GLSLShader deferredGeometryFS {
	
	layout(location = 0) in vec3 in_PositionVS;
	layout(location = 1) in vec3 in_Normal;
	layout(location = 2) in vec2 in_TexCoord;
	layout(location = 3) in vec4 in_Color;	
	
	layout(location=0) out vec2 outNormal;
	layout(location=1) out vec4 outColor;
	
	void main() {		
		vec3 position = in_PositionVS;
		
		//store normal
		vec3 normal = normalize(in_Normal);
		outNormal = vec2(normal.x, normal.z);
		
		
		//store color
		outColor = in_Color;
		
		//store depth
		//outDepth = depth;
		
		/*
		vec4 color = in_Color;
		vec3 texCoord = vec3(in_TexCoord, 1.0);
		float z = in_PositionVS.z;
		float shininess = 1.0;
		finalDeferredGeometry(position, normal, color, z);
		*/
	}		
}

GLSLShader simpleColorOutFS {

	layout(location = 0) in vec3 in_PositionVS;
	layout(location = 1) in vec3 in_Normal;
	layout(location = 2) in vec2 in_TexCoord;
	layout(location = 3) in vec4 in_Color;
	
	layout(location=0) out vec4 outColor;
	
	void main() {
	     outColor = in_Color;
	}
}
///
//

//--------------------------------------------------------------------------------------
//    Deferred Rendering Lighting Pass
//--------------------------------------------------------------------------------------
GLSLShader global deferredLightingVS
{
	layout(location=0) in vec3 position;
	layout(location=1) in vec3 texCoord;
	
	layout(location=1) out vec3 out_TexCoord;
	
	out gl_PerVertex{
		vec4 gl_Position;
	};
	
    void main()
    {	
		gl_Position = vec4(position,1.0);
		out_TexCoord = texCoord;
	}
}

GLSLShader global deferredLightingPS
{

    uniform sampler2D colorTexture;
	uniform sampler2D depthTexture;
	uniform sampler2D normalTexture;
	
    layout(location=1) in vec3 in_TexCoord;
	
    layout(location = 0) out vec4 color;

    vec3 reconstructPosition(in float depth, in vec2 coord){
	vec4 v = (m4_ProjectionI * (vec4(coord, depth, 1.0) * 2.0 - 1.0));
	return v.xyz / v.w;
    }
	
    void main()
    {		    
		float depth = texture(depthTexture, in_TexCoord.xy).x;				
		//if(depth >= 1.0) discard;
		
		vec3 position = reconstructPosition(depth, in_TexCoord.xy);
				
		vec2 normalXY = texture(normalTexture, in_TexCoord.xy).xy;
		vec3 normal = vec3(normalXY.xy, 1.0 - normalXY.x * normalXY.x - normalXY.y * normalXY.y);
		
		vec4 diffuseColor = texture(colorTexture, in_TexCoord.xy);
		vec4 resultColor = vec4(0.0,0.0,0.0,0.0);
		for(int i = 0 ; i < i_NumLights; ++i){
			vec3 l_pos = light_position(i);
			
			vec3 l_vec = normalize(l_pos - position);
			vec4 l_diffuse = vec4(light_diffuse(i), 1.0);
						
			if(l_pos == vec3(0.0, 0.0, 0.0)){
				color = vec4(0.3, 0.3, 0.3, 1.0);
				return;
			}
						
			if(l_diffuse == vec4(0.0, 0.0, 0.0, 1.0)) {
				color = vec4(0.3, 0.3, 0.3, 1.0);
				return;
			}
						
			resultColor += diffuseColor * l_diffuse * dot(l_vec, normal);
		}
		
		color = vec4(1.0, 1.0, 1.0, 1.0); //resultColor;
	}
}
///
//

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
// DeferredRendering Scene Level Technique
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
Technique DeferredRendering
{
    Pass deferredGeometry
    {
        DEPTH_TEST = true;
		/*
		STENCIL_TEST = true;
		STENCIL_FUNC = Always;
		STENCIL_VALUE_MASK = 255;
		STENCIL_REF = 1;
		STENCIL_FAIL = KEEP;
		STENCIL_PASS_DEPTH_FAIL = KEEP;
		STENCIL_PASS_DEPTH_PASS = INCR;
		*/
        CULL_FACE = false;
        BLEND = false;
        RenderMode = SceneShading;
        RenderGroup = 11;
        ClearMode = all;
        ClearColor[0] = {0,0.0,0.0,1};
        ClearColor[1] = {0.0,0.0,0.0,1};
		VertexProgram = deferredGeometryVS;
		FragmentProgram = deferredGeometryFS;
        CurrentTarget = deferredRenderFBO;
        //FragmentProgram<"out"> = DeferredGeometry;
    }
    
    // Fullscreen-quad for light pass
    Pass deferredLighting
    {
		/*
		STENCIL_TEST = true;
		STENCIL_FUNC = Greater;
		STENCIL_VALUE_MASK = 255;
		STENCIL_REF = 0;
		STENCIL_FAIL = KEEP;
		STENCIL_PASS_DEPTH_FAIL = KEEP;
		STENCIL_PASS_DEPTH_PASS = KEEP;
		*/
        DEPTH_TEST = false;
        CULL_FACE = false;
        BLEND = false;
        BLEND_SRC = ONE_MINUS_CONSTANT_COLOR;
        BLEND_DST = CONSTANT_COLOR;
        BLEND_COLOR = {0.3,0.3,0.3,0.3};
        RenderMode = render_fullscreen_quad;//DebugQuad3; // Only draws a quad... Won't change any renderstate. So Depth test/Cullface would be needed
        VertexProgram = deferredLightingVS;
        SamplerResource(normalTexture) = rt_Normal;
		SamplerResource(colorTexture) = rt_Color;
		SamplerResource(depthTexture) = rt_Depth;
        SamplerState(quadSampler) = nearestSampler; // Strange: I can't use any other sampling filtering to not break the FBO
        FragmentProgram = deferredLightingPS;
        CurrentTarget = deferredRenderLightFBO;
		//FragmentProgram<"out"> = DeferredLighting;
		FragmentProgram<"light"> = LightCalculation;
    }
    
    Pass blitToScreen
    {	
	BlitFBOToActiveTarget = deferredRenderLightFBO;
        //Viewport = ApplicationDefined;
        CurrentTarget = backbuffer;
    }
}

Technique SceneToBackbuffer 
{
    Pass renderScene 
    {
	DEPTH_TEST = true;
	CULL_FACE = false;
	BLEND = false;
	RenderMode = SceneShading;
	ClearMode = all;
	ClearColor[0] = {0.0, 0.0, 0.0, 1.0};
	CurrentTarget = backbuffer;
	VertexProgram = deferredGeometryVS;
	FragmentProgram = simpleColorOutFS;
    }
}

// Simpler case
Technique NormalsAsColorToBackbuffer
{
    Pass renderScene
    {
        DEPTH_TEST = true;
        CULL_FACE = true;
        BLEND = false;
        RenderMode = SceneShading;
        RenderGroup = 11;
        ClearMode = all;
        ClearColor[0] = {0,0.0,0.0,1};
        ClearColor[1] = {0.3,0.2,0.4,1};
        CurrentTarget = backbuffer;
        FragmentProgramOverride<"out"> = NormalsAsColor;
    }
}

// display TC
Technique TcAsColorToBackbuffer
{
    Pass renderScene
    {
        DEPTH_TEST = true;
        CULL_FACE = true;
        BLEND = false;
        RenderMode = SceneShading;
        RenderGroup = 11;
        ClearMode = all;
        ClearColor[0] = {0,0.0,0.0,1};
        ClearColor[1] = {0.3,0.2,0.4,1};
        CurrentTarget = backbuffer;
        FragmentProgramOverride<"out"> = TcAsColor;
    }
}